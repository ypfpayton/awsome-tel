# Java虚拟机

## 类加载

![类加载过程](https://tva1.sinaimg.cn/large/007S8ZIlly1gj7t2gw8xxj30ha05saax.jpg)

1. 类加载主要分为三个过程，分别是加载、连接、初始化，其中连接过程又分为验证、准备、解析三个步骤。

2. 加载过程

   ，在这个过程虚拟机需要完成三件事情

   1. 根据类的全限定名获取定义此类的二进制字节流
   2. 将该二进制字节流所代表的静态存储结构转化为方法区中的运行时数据结构
   3. 在内存中生成一个代表该类的java.lang.Class对象，作为方法区中这个类的各种数据的访问入口。

3. 验证阶段

   ：目的是确保Class文件的字节流中包含的信息合法，又分为

   1. **文件格式验证**：验证字节流是否符合Class文件格式的规范，比如魔数、主次版本号、常量池等。
   2. **元数据验证**：对字节码描述的信息进行语义分析，对类的元数据信息进行语义校验。是否有父类、是否继承了不该继承的类，诸如此类。
   3. **字节码验证**：通过数据流分析和控制流分析，确定程序语义是否合法，是否符合逻辑。
   4. **符号引用验证**：目的是确保解析行为能够正常进行。

4. **准备阶段**：为类中定义的变量(即静态变量，被`static`修饰的变量)分配内存并设置类变量初始值。

5. 解析阶段

   ：将常量池内的符号引用替换为直接引用的过程

   1. 类或接口的解析
   2. 字段解析
   3. 方法解析
   4. 接口方法解析

6. 初始化阶段

   ：此前的阶段都由JVM来主导，初始化阶段开始JVM才真正执行类中编写的Java程序代码，将主导权交给应用程序。

   1. 初始化阶段，会根据程序员通过程序编码制定的主观计划去初始化类变量和其他资源。
   2. 其实就是执行类构造器`<clinit>()`方法的过程，这个方法是Javac编译器的生成物。



## 类加载器种类

类加载器有三层，分别是：

- 启动类加载器（Bootstrap Class Loader）：负责加载存放在`<JAVA_HOME>/lib`目录，或者被`-Xbootclasspath`所指定的路径中存放的，而且能够被JVM识别的类库加载到虚拟机的内存中。
- 扩展类加载器（Extension Class Loader）：负责加载`<JAVA_HOME>/lib/ext`目录中，或者被`java.ext.dirs`系统变量所指定的路径中所有的类库。
- 应用程序类加载器（Application Class Loader）：负责加载用户类路径（ClassPath）上所有的类库，如果应用程序中没有自定义过类加载器，这就是默认的类加载器
- User ClassLoader 用户自定义类加载器

![image-20211214153124098](C:\Users\y00608930\AppData\Roaming\Typora\typora-user-images\image-20211214153124098.png)

 一般认为上一层加载器是下一层加载器的父加载器，那么，除了BootstrapClassLoader之外，所有的加载器都是有父加载器的

双亲委派机制，指的就是：**当一个类加载器收到了类加载的请求的时候，他不会直接去加载指定的类，而是把这个请求委托给自己的父加载器去加载。只有父加载器无法加载这个类的时候，才会由当前这个加载器来负责类的加载。**

**通过委派的方式，可以避免类的重复加载**，当父加载器已经加载过某一个类时，子加载器就不会再重新加载这个类。

**通过双亲委派的方式，还保证了安全性**。因为Bootstrap ClassLoader在加载的时候，只会加载JAVA_HOME中的jar包里面的类，如java.lang.Integer，那么这个类是不会被随意替换的，除非有人跑到你的机器上， 破坏你的JDK



### "父子加载器"之间的关系是继承吗？

**双亲委派模型中，类加载器之间的父子关系一般不会以继承（Inheritance）的关系来实现，而是都使用组合（Composition）关系来复用父加载器的代码的。**



### 如何自己实现类加载器？

1. 继承`java.lang.ClassLoader`类
2. 如果想打破双亲委派模型的话，重写`loadClass()`类
3. 如果不想打破双亲委派模型的话，重写`findClass()`类

### Tomcat 是如何违背双亲委派模型的？

Tomcat 作为 Web 容器：

1. 需要支持**文件的热修改**；
2. 相同 Web 容器中不同应用程序相互隔离(不同应用程序可能会依赖相同的第三方类库的不同版本)；
3. Web 容器也有自己依赖的类库，不能与应用程序的类库混淆；
4. 需要**隔离性**。

![Tomcat 类加载模型](https://tva1.sinaimg.cn/large/007S8ZIlly1gj7taxqg87j30cu0i774f.jpg)

在 Tomcat 的类加载机制中：

- 最上层三个类加载器仍然是系统类加载器相同；
- commonLoader：Tomcat最基本的类加载器，加载路径中的class可以被Tomcat容器本身以及各个Webapp（web应用）访问；
- catalinaLoader：Tomcat容器私有的类加载器，加载路径中的class对于Webapp不可见；
- sharedLoader：各个Webapp共享的类加载器，加载路径中的class对于所有Webapp可见，但是对于Tomcat容器不可见；
- WebappClassLoader：各个Webapp私有的类加载器，加载路径中的class只对当前Webapp可见；如果 Common ClassLoader 想加载 WebApp ClassLoader 中的类该怎么办？

> CommonClassLoader能加载的类都可以被Catalina ClassLoader和SharedClassLoader使用，从而实现了公有类库的共用，而CatalinaClassLoader和Shared ClassLoader自己能加载的类则与对方相互隔离。
>
> WebAppClassLoader可以使用SharedClassLoader加载到的类，但各个WebAppClassLoader实例之间相互隔离。
>
> 而JasperLoader的加载范围仅仅是这个JSP文件所编译出来的那一个.Class文件，它出现的目的就是为了被丢弃：当Web容器检测到JSP文件被修改时，会替换掉目前的JasperLoader的实例，并通过再建立一个新的Jsp类加载器来实现JSP文件的HotSwap功能。



## JMM模型

![image-20211123115535038](C:\Users\y00608930\AppData\Roaming\Typora\typora-user-images\image-20211123115535038.png)

- 5大内存区域
  - Heap堆
    - 存放java对象，同一个java进程下的多线程共享
  - 方法区（java8称为元空间）
    - 跟堆一样，所有java线程共享内存区域
    - 存储已被虚拟机加载的类信息、常量、静态变量
  - 虚拟机栈
    - 存放方法参数，以及方法内定义的局部变量，存放着编译期间已知的数据类型(八大基本类型和对象引用(reference类型),returnAddress类型
    - 最小单位为slot，long/double占2个slot，其他类型占1个slot
    - 局部变量所需的空间在编译期完成分配，及进入方法时已经完全确定所需要的内存空间
    - 会抛2种异常：超出栈的深度异常stackoverflowError、申请内存不足：outofmemory
  - 本地方法栈
  - 程序计数器：保存程序运行的地址空间



### 垃圾回收

- 回收区域

  - 新生代
  - 老年代
  - 永久代（java8 称为 元空间）

- 对象存活探测算法：GC Roos（可达性分析算法）

  - 从root根对象可达的对象都不可回收
  - 根对象
    - 虚拟机栈(栈桢中的本地变量表)中的引用的对象（当前方法栈还在使用）
    - 方法区中的类静态属性引用的对象，一般指被static修饰
    - 方法区中的常量引用的对象
    - 本地方法栈中JNI（native方法)引用的对象

- 新生代垃圾回收算法：复制算法

  - 复制算法用于复制存活率较低的对象，直接进行复制到另一个内存区域，这样效率较高
  - 将内存分为三个区域，三个区域一般内存占比为8:1:1
    - Eden 【伊甸区】
    - From Survivor 【存活区】
    - To Survivor【保留空间】
  - GC一开始时To Survivor为空，Eden区所有存活的对象都被复制到To Survivor区，而From Survivor区中，仍存活的对象会根据它们的年龄值决定去向，年龄值达到年龄阈值(默认15是因为对象头中年龄战4bit，新生代每熬过一次垃圾回收，年龄+1)，则移到老年代，没有达到则复制到To Survivor。

- 老年代（元空间）垃圾回收算法：标志清楚/整理算法

  - 标志：采用GC Roots搜索，标志垃圾对象
  - 清除：垃圾对象直接清理（标记和清除两个过程的效率都不高，标记清除后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要 分配较大对象时，无法找到足够的连续内存而不得不提前出发另一次垃圾收集动作。）
  - 整理：将所有的存活对象压缩到内存的一段，之后清理边界外所有的空间（效率比清除会高，它并不简单的清理未标记的对象，而是将所有的存活对象压缩到内存的一端。之后，清理边界外所有的空间）

- 枚举根节点算法

  - 执行一次GC Roos开销很大，当方法区达到几百兆，这个过程称为STW(stop the world)， 所有工作都是暂停的
  - 如果高效执行GC Roos，hotpot采用OopMap数据结构，存放一个对象内什么偏移量上是什么类型的数，可以理解一个衣服的吊牌，记录这是一件什么衣服，这是一种通过空间换取时间的算法，达到快速搜索目的
  - 实际上在编译过程中，编译器会在不同的位置记录OopMap，这种称为savepoint（安全点），GC必须达到安全点才能执行

- 查看GC日志

  - 通过启动参数-XX:+PrintGCDetails
  - 通过jstat -gcutil pid查看对应java进程gc情况

- GC触发

  - minor gc： Eden区满了触发
  - full gc触发条件：
    - 代码system.gc 概率性执行
    - 老年代空间不足
    - 方法区空间

- 空间分配担保

  minor gc在复制新生代对象到老年代的连续内存空间内，假设老年代的空间够，不会触发full gc；假如晋升的大对象老年代无法容纳的话，就会触发full gc了，所以要考虑新生代大对象以及老年代内存碎片问题
