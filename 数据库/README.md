## **平衡二叉树**

![img](https://pic1.zhimg.com/80/v2-28e39093993f673de576f57ea614d604_720w.jpg)

总结平衡二叉树特点：

（1）非叶子节点最多拥有两个子节点；

（2）非叶子节值大于左边子节点、小于右边子节点；

（3）树的左右两边的层级数相差不会大于1;

（4）没有值相等重复的节点;



## **B树(B-tree)**

> B树和平衡二叉树稍有不同的是B树属于多叉树又名平衡多路查找树（查找路径不只两个），数据库索引技术里大量使用者B树和B+树的数据结构

![img](https://pic2.zhimg.com/80/v2-2c2264cc1c6c603dfeca4f84a2575901_720w.jpg)

**B树的查询流程：**

如上图我要从上图中找到E字母，查找流程如下

（1）获取根节点的关键字进行比较，当前根节点关键字为M，E<M（26个字母顺序），所以往找到指向左边的子节点（二分法规则，左小右大，左边放小于当前节点值的子节点、右边放大于当前节点值的子节点）；

（2）拿到关键字D和G，D<E<G 所以直接找到D和G中间的节点；

（3）拿到E和F，因为E=E 所以直接返回关键字和指针信息（如果树结构里面没有包含所要查找的节点则返回null）

**特点：**

B树相对于平衡二叉树的不同是，每个节点包含的关键字增多了，特别是在B树应用到数据库中的时候，数据库充分利用了磁盘块的原理磁盘数据存储是采用块的形式存储的，每个块的大小为4K，每次IO进行数据读取时，同一个磁盘块的数据可以一次性读取出来）把节点大小限制和充分使用在磁盘快大小范围；把树的节点关键字增多后树的层级比原来的二叉树少了，减少数据查找的次数和复杂度;



## **B+树**

> B+树是B树的一个升级版，相对于B树来说B+树更充分的利用了节点的空间，让查询速度更加稳定，其速度完全接近于二分法查找。

![preview](https://pic4.zhimg.com/v2-5f069fd820637db1b877fdd6799a2b67_r.jpg)

（1）B+跟B树不同B+树的**非叶子**节点不保存关键字记录的指针，只进行数据索引，这样使得B+树每个**非叶子**节点所能保存的关键字大大增加；

（2）B+树**叶子**节点保存了父节点的所有关键字记录的指针（索引），并且指向数据；

（3）B+树叶子节点的关键字从小到大有序排列，左边结尾数据都会保存右边节点开始数据的指针，所有叶子节点都相连。

（4）非叶子节点的子节点数=关键字数（根据各种资料 这里有两种算法的实现方式，另一种为非叶节点的关键字数=子节点数-1，虽然他们数据排列结构不一样，但其原理还是一样的Mysql 的B+树是用第一种方式实现）;

**特点**

1、B+**树的层级更少**：相较于B树B+每个**非叶子**节点存储的关键字数更多，树的层级更少所以查询数据更快；

2、B+**树查询速度更稳定**：B+所有关键字数据地址都存在**叶子**节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定;

3、B+**树天然具备排序功能：**B+树所有的**叶子**节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比B树高。

4、B+**树全节点遍历更快：**B+树遍历整棵树只需要遍历所有的**叶子**节点即可，，而不需要像B树一样需要对每一层进行遍历，这有利于数据库做全表扫描。

**B树**相对于**B+树**的优点是，如果经常访问的数据离根节点很近，而**B树**的**非叶子**节点本身存有关键字其数据的地址，所以这种数据检索的时候会要比**B+树**快。


## 为什么选择用 B+ 树

常用的 SQL 主要包括三类：

1. 根据某个值进行精确查找（**等值查询**）
2. 按照**区间查询**
3. 进行**顺序查找或逆序查找**

结合以上三点考虑，

- 哈希虽然能够提供 O(1)O(1) 的查询性能，但是只支持**等值查询**，不适用**范围查询**和**排序查询**，最终导致全表扫描；
- B+ 树中间节点只存索引，不存数据，所以体积更小，相比 B 树，在磁盘页大小一定（如4KB）时，单页磁盘可以存储更多 B+ 树节点，一次读入内存的数据项也更多，减少了 IO 次数。
- B+ 树的叶节点通过指针串联成双向链表，尽管等值匹配时效率不如**哈希**，但是 B+ 树是多路平衡查找树，树的高度可以很低，最坏查找效率也为**对数级别** (log_m NlogmN)，最主要的是 B+B+ 树非常适合**区间查询**与**顺序查询**。
- B 树的非叶子节点中存储数据，这导致在**查询连续数据时**可能会带来更多的随机 I/O，而 B+ 树因为叶节点串联成双向链表，适合顺序 I/O。

## 主键自增与使用 UUID

> 当达到页面最大装填因子时，新数据将会插入到新的页面中。InnoDB 默认的最大装填因子为 15/16，其余 1/16 用于修改操作。

**采用主键自增时：**因为值是顺序的，所以新插入记录总是会在已有记录后面，所以：

- 因为主键自增有序，数据将会以顺序方式追加数据页，提高了页面的填充率，避免页面浪费。
- 因为是顺序追加，所以在新插入数据的地址计算方便，不需要因为寻址消耗太多的性能。
- 减少了页分裂与页面碎片的产生。

**采用 UUID 作为主键时：**新行主键不一定比已有主键大，所以需要为新行寻找存储地址，数据的无顺序性将会导致数据分布散乱。

- 待写入的目标也可能已经刷新到磁盘并且已从缓存中移除，或者还没有被加载到内存中，存储引擎需要在插入前先**找到磁盘**，然后将数据也**读取到内存**。在这个过程中将会导致大量的随机 IO。
- 因为数据写入乱序，将会导致频繁的**页面分裂**，进而导致大量的数据移动，以便为新行分配空间。
- 由于**无顺序性**以及频繁的**页面分裂**，将会使数据页变得**稀疏**，产生**页面碎片**。在有时使用 **OPTIMIZE TABLE** 来重建表并优化**页面填充**时也会浪费时间。

**使用 InnoDB 应该尽可能的按主键的自增顺序插入，并且尽可能使用单调的增加的聚簇键的值来插入新行。**

## 索引失效有哪些场景？
1. 索引列参与了计算
2. 索引列使用了 MySQL 中的函数
3. 使用了前置模糊查询，like '%hello' 不走索引，like hello%'走索引
4. 索引列使用了正则表达式
5. 索引列进行了非等值查询，也就是范围查询(不满足最左匹配)。
6. 字符串与数字进行了比较
7. OR 条件连接时某些列没有加索引
